#include "syscalls.h"

#include <signal.h>

#include "../../ipc/include/pipe.h"
#include "../semaphore/include/semaphore.h"
#include "keyboardDriver.h"

#define STDIN 0
#define STDOUT 1

#define VERDE 0x8bd450
#define VIOLETA 0x8b4bd4
#define BLANCO 0xffffff
#define NEGRO 0x000000

#define TAB_SPACES 4

// Coordinadas del cursor
static uint16_t x_coord = 0;
static uint16_t y_coord = 0;

Registers_t snapshot = {0};
bool snapshotReady = false;

void resetCursorCoord()
{
	x_coord = 0;
	y_coord = 0;
}

void loadSnapshot(Registers_t *regs)
{
	if (regs == NULL)
	{
		return;
	}

	memcpy(&snapshot, regs, sizeof(Registers_t));
	snapshotReady = true;
}

uint8_t isSpecialChar(char c)
{
	return (c == '\n' || c == '\r' || c == '\t' || c == '\b');
}

// TODO: Creo que la sys_write no deberia imprimir en pantalla, ver si se puede modularizar
uint64_t sys_write(const uint8_t fd, const char *str, const uint64_t count)
{
	if (fd < 0)
	{
		return -1;
	}

	// TODO: implementar STDERR
	if (fd == STDOUT)
	{
		int width = getWidth();
		int height = getHeight();

		for (uint64_t i = 0; i < count; i++)
		{
			if (isSpecialChar(str[i]))
			{
				switch (str[i])
				{
					case '\n':
						y_coord += height + FONT_CHAR_GAP;

					case '\r':
						x_coord = 0;
						break;

					case '\t':
						x_coord += (TAB_SPACES * (width + FONT_CHAR_GAP));
						if (x_coord >= getScreenWidth())
						{
							x_coord = x_coord % getScreenWidth();
							y_coord += height + FONT_CHAR_GAP;
						}
						break;

					case '\b':

						if (x_coord > width + FONT_CHAR_GAP)
						{
							x_coord -= (width + FONT_CHAR_GAP);
						}
						else
						{
							if (y_coord > 0)
							{
								y_coord -= (height + FONT_CHAR_GAP);
								x_coord = getScreenWidth() - TAB_SPACES * (width + FONT_CHAR_GAP) + x_coord;
							}
							else
							{
								x_coord = 0;
							}
						}

						// TODO: Esto en vez del un espacio tendria que ser un caracter con todo
						// el bit map en 1. Tambien sirve para el cursor
						drawRectangle(width, height, NEGRO, x_coord, y_coord);
						break;
				}
			}

			// TODO: Aca se podria optimizar con getRemainingScreenWidth
			else if (isValidScreenPrint(x_coord, y_coord, width, height))
			{
				drawChar(str[i], BLANCO, x_coord, y_coord);
				x_coord += width + FONT_CHAR_GAP;
			}
			else
			{
				x_coord = 0;
				y_coord += height + FONT_CHAR_GAP;
			}
		}

		return count;
	}

	return pipe_write(fd, (char *) str, count);
}

uint64_t sys_read(uint8_t fd, char *buffer, uint64_t count)
{
	if (fd == STDIN)
	{
		// Verificar si se presionó Ctrl+D antes de leer
		if (kbd_check_eof())
		{
			return 0; // EOF: retornar 0 bytes leídos
		}

		for (uint64_t i = 0; i < count; i++)
		{
			buffer[i] = kbd_get_char();

			// Verificar EOF después de cada carácter
			if (kbd_check_eof())
			{
				return i; // Retornar los bytes leídos hasta ahora
			}
		}

		return count;
	}

	return pipe_read(fd, buffer, count);
}

void syscallDispatcher(Registers_t *regs)
{
	// El número de la syscall generalmente se pasa en RAX
	uint64_t syscall_id = regs->rax;

	// Los argumentos suelen pasarse en RDI, RSI, RDX, RCX, R8, R9 (según la convención de llamada de System V AMD64)
	uint64_t arg1 = regs->rdi;
	uint64_t arg2 = regs->rsi;
	uint64_t arg3 = regs->rdx;
	uint64_t arg4 = regs->rcx;
	uint64_t arg5 = regs->r8;
	uint64_t arg6 = regs->r9;

	/*
		Las que son 0x1... son syscalls de video
	*/

	switch (syscall_id)
	{
		case 0x1:
			sys_write(arg1, (const char *) arg2, arg3);
			regs->rax = arg1;
			break;

		case 0x2:
			regs->rax = sys_read(arg1, (char *) arg2, arg3);
			break;

		case 0x04:
			if (!snapshotReady)
			{
				regs->rax = 1; // error: no hay snapshot
			}
			else
			{
				uint64_t *out = (uint64_t *) arg1;
				memcpy(out, &snapshot, sizeof(Registers_t));
				regs->rax = 0;
			}
			break;

		case 0x05:
			dateTime *dt = (dateTime *) arg1;
			getTime(dt);
			regs->rax = 0;
			break;

		case 0x06:
			zoomInFont();
			clearScreen();
			x_coord = 0;
			y_coord = 0;
			// drawString("ZOOM IN PERRO", VERDE, 200, 200);
			break;

		case 0x07:
			zoomOutFont();
			clearScreen();
			x_coord = 0;
			y_coord = 0;
			// drawString("ZOOM OUT PERRO", VIOLETA, 250, 250);
			break;

		case 0x10:
			clearScreen();
			x_coord = 0;
			y_coord = 0;
			regs->rax = 0;
			break;

		case 0x11:
			putPixel((uint32_t) arg1, arg2, arg3);
			regs->rax = 0;
			break;

		case 0x12:
			drawChar((char) arg1, (uint32_t) arg2, arg3, arg4);
			regs->rax = 0;
			break;

		case 0x13:
			drawString((const char *) arg1, (uint32_t) arg2, arg3, arg4);
			regs->rax = 0;
			break;

		case 0x14:
			drawRectangle(arg1, arg2, (uint32_t) arg3, arg4, regs->r8);
			regs->rax = 0;
			break;

		case 0x15:
			drawDecimal(arg1, (uint32_t) arg2, arg3, arg4);
			regs->rax = 0;
			break;

		case 0x16:
			drawHexa(arg1, (uint32_t) arg2, arg3, arg4);
			regs->rax = 0;
			break;

		case 0x17:
			drawBin(arg1, (uint32_t) arg2, arg3, arg4);
			regs->rax = 0;
			break;

		case 0x18:
			regs->rax = getScreenWidth();
			break;

		case 0x19:
			regs->rax = getScreenHeight();
			break;

		case 0x20:
			regs->rax = kbd_get_char();
			break;

		// TODO: este no quedo organizado como los demas
		case 0x21:
			drawCircle(arg1, (uint32_t) arg2, arg3, arg4);
			regs->rax = 0;
			break;

		case 0x30:
			playSoundForDuration((uint32_t) arg1, (uint32_t) arg2);
			regs->rax = 0;
			break;

		case 0x40:
			sleep(arg1);
			regs->rax = 0;
			break;

		case 0x50:
			regs->rax = createProcess((char *) arg1, (mainFuncPtr) arg2, (int) arg3, (char **) arg4, (int16_t *) arg5,
									  (bool) arg6);
			break;

		case 0x51:
			regs->rax = killProcess((uint64_t) arg1);
			break;

		case 0x52:
			regs->rax = getPid();
			break;

		case 0x53:
			// arg1 = buffer, arg2 = bufferSize
			regs->rax = getAllProcessesInfo((char *) arg1, (uint64_t) arg2);
			break;

			// case 0x54:
			// TODO: Falta implementar este, tendria que matar a un proceso

		case 0x55:
			changeProcessPriority((uint64_t) arg1, (uint8_t) arg2);
			regs->rax = 0;
			;
			break;

		case 0x56:
			blockProcess((uint64_t) arg1);
			regs->rax = 0;
			break;

		case 0x57:
			unblockProcess((uint64_t) arg1);
			regs->rax = 0;
			break;

		case 0x58:
			yield();
			regs->rax = 0;
			;
			break;

		case 0x59:
			regs->rax = waitPid((uint64_t) arg1);
			break;

			// Semaforos
		case 0x60:
			regs->rax = (uint64_t) semOpen((const char *) arg1, (int) arg2);
			break;

		case 0x61:
			semClose((semaphoreP) arg1);
			regs->rax = 0;
			break;

		case 0x62:
			semWait((semaphoreP) arg1);
			regs->rax = 0;
			break;

		case 0x63:
			semPost((semaphoreP) arg1);
			regs->rax = 0;
			break;

		case 0x64:
			regs->rax = semTryWait((semaphoreP) arg1);
			break;

		case 0x65:
			regs->rax = semGetValue((semaphoreP) arg1, (int *) arg2);
			break;

		case 0x66:
			regs->rax = sem_unlink((const char *) arg1);
			break;

		case 0x80:
			regs->rax = pipe_open((int16_t *) arg1);
			break;

		case 0x81:
			regs->rax = pipe_close((int) arg1);
			break;

		case 0x90:
			mem_get_stats((pm_stats_t *) arg1);
			regs->rax = 0;
			break;

		case 0x91:
			regs->rax = (uint64_t) mem_alloc((size_t) arg1);
			break;

		case 0x92:
			mem_free((void *) arg1);
			break;

		case 0x100:
			regs->rax = getProcesFd((int) arg1);
			break;

		case 0x101:
			regs->rax = getProcessStatus((uint64_t) arg1);
			break;

		default:
			// Syscall desconocida o no implementada
			// Se imprime un error o se establece un código de error en rax
			regs->rax = (uint64_t) -1; // Ejemplo de error (ENOSYS)
			break;
	}
}
